1 - Only one level of indentation per method

2 - Never use else

3 - Encapsulate all primitive types and strings
(obsession with primitive types)
- Low code reuse
- Impossible to write unit tests
- Causes code duplication
- High coupling
- Primitive types have no behavior
- Impossibility of using DDD tactical modeling
(Value Objects)

4 - Wrap collections in classes

5 - Use only one dot per line (Law of Demeter)

6 - Do not abbreviate variable and method names

7 - Keep all classes small (max 50 lines)

8 - No class with more than two instance variables

never execute npm run dev without before see if this is already running
# üß† Development Guidelines for Locate-Family-Connect

*Updated: 2025-05-05*

---

## ‚öôÔ∏è Git Command Automation
Always use:
```bash
git status
git add -A
git commit -m "your detailed message [type: fix/feature/docs]"
git push
```

---

## üë®‚Äçüíª Your Role
You are a senior engineer focused on the Locate-Family-Connect system, which connects guardians and students through location sharing and secure notifications. Prioritize data security, authentication flow stability, and Edge Functions performance.

---

## üèóÔ∏è Project Architecture and Stack
- **Frontend:** React + TypeScript + Vite
- **UI:** Custom components + Radix UI + TailwindCSS
- **Backend:** Supabase (PKCE Auth, PostgreSQL, Edge Functions)
- **Maps:** MapBox for location visualization and sharing
- **Emails:** Resend API (domain: sistema-monitore.com.br)
- **App:** SPA with profile-based authentication flow (guardian/student)

### Critical File Structure
- `/src/contexts/UnifiedAuthContext.tsx` ‚Äì PKCE authentication management
- `/src/lib/supabase.ts` ‚Äì Supabase Client instance and configuration
- `/src/App.tsx` ‚Äì Routes protected by user type
- `/src/lib/db/migrations/` ‚Äì SQL migrations with RLS policies and triggers
- `/supabase/functions/share-location/` ‚Äì Edge Function for location sharing via email
- `/src/components/guardian/`, `/src/components/student/` ‚Äì User profile-specific components
- `/scripts/` ‚Äì Diagnostic scripts (test-resend.mjs, test-email.mjs, test-db-connection.js)
- `/docs/` ‚Äì Technical documentation (configuracao-resend.md, edge-functions.md)

---

## üß± Structure and Organization
- Split large files into smaller modules (<300 lines).
- Separate authentication logic from business logic.
- Maintain consistency in folder structure by profile (`student/`, `guardian/`).
- Use well-defined RLS policies instead of frontend authorization logic.
- Implement all Edge Functions with detailed logs and error handling.
- Centralize external API configuration (Resend, MapBox) in dedicated files.
- Store sensitive data only in environment variables.

---

## üåç Environments and Configuration
- **Resend API:** ALWAYS use the updated key (check in `/docs/configuracao-resend.md`).
- **Edge Functions:** Update secret keys via Supabase CLI (never hardcoded).
- **Supabase:** Maintain consistency between local and production environments with `supabase link`.
- **Database:** Keep all migrations versioned and applied in order.
- **Indexes:** Maintain indexes for `guardians_student_id_idx`, `guardians_email_idx`, `idx_users_user_type`.
- **Transactions:** Use transactions for multiple operations (especially in user registration).
- **Diagnostics:** Regularly run the scripts `/scripts/test-resend.mjs` and `/scripts/conexao-supabase.mjs`.

---

## üîÅ Reuse & Consistency
- Reuse existing components for authentication flows.
- Maintain hook patterns in `src/hooks/` (e.g., `useStudentLocations`).
- Follow the existing type structure in `src/types/`.
- Use formatting and validation utilities in `src/lib/utils/`.
- Reuse existing style configurations instead of duplicating styles.
- Maintain consistency in database interaction via named SQL functions.

---

## üß† Planner Mode
1. Reflect on impacts to authentication flow and location sharing.
2. Review `UnifiedAuthContext.tsx`, Edge Functions, and related RLS policies.
3. Check implications for both profiles (guardian/student).
4. Ask questions about impact on Resend and MapBox integrations.
5. Check for potential conflicts with existing triggers and SQL functions.
6. Consider the impact on Row Level Security policies.
7. Propose a plan focusing on security and backwards compatibility.
8. Implement in stages, testing each profile separately.

---

## üß™ Debugger Mode
1. Check issues in critical integrations:
¬† ¬†- Supabase Authentication (PKCE)
¬† ¬†- Emails via Resend (domain verification)
¬† ¬†- Edge Function `share-location`
¬† ¬†- RLS policies in `locations` and `guardians` tables
¬† ¬†- SQL triggers for `handle_new_user`
2. Check specific logs:
¬† ¬†- Supabase Auth Logs (`public.auth_logs`)
¬† ¬†- Edge Function `share-location` logs
¬† ¬†- Resend API responses
¬† ¬†- Supabase Client errors
3. Use diagnostic scripts:
¬† ¬†- `/scripts/test-resend.mjs`
¬† ¬†- `/scripts/test-email.mjs`
¬† ¬†- `/scripts/conexao-supabase.mjs`
4. Verify API key consistency (especially Resend).
5. Test complete authentication and sharing flows.
6. Verify database structure integrity with migrations.

---

## üß© Dev Experience
- Prioritize authentication flow and password recovery (critical).
- Start by testing with users of both profiles (student/guardian).
- Verify Edge Function `share-location` functionality.
- Validate profile synchronization via the `handle_new_user` trigger.
- Test email notifications with the verified domain.
- Ensure RLS policies are working correctly.
- Document any changes to critical files.

---

## üó£Ô∏è Interaction
- Clearly communicate issues in authentication flow or sharing.
- Show visual examples of emails sent by the application.
- Use flowcharts to explain guardian-student relationships.
- Provide detailed logs when reporting errors.
- Document domain configuration steps in Resend.
- Keep documentation updated about API keys and secrets.

---

## üîç Project Vision
Always clarify:
- Expected behavior of real-time location updates
- Format and content of sharing emails
- Expected password recovery flow for each profile
- Dashboard behavior specific to each user type
- Expected permissions between guardians and students
- Integrations with external services (Resend, MapBox)

---

## üîê Security
- **Emails:** ONLY use the verified domain `sistema-monitore.com.br` with Resend.
- **API Keys:** Maintain consistency with the main Resend API key.
- **Auth:** Correctly implement the Supabase PKCE flow.
- **RLS:** Maintain policies for all tables (`locations`, `profiles`, `guardians`).
- **Edge Functions:** Implement JWT token validation and rate limiting.
- **Database:** Always use transactions and SQL functions with SECURITY DEFINER.
- **Triggers:** Maintain the `handle_new_user()` trigger for profile synchronization.
- **Logs:** Use the `auth_logs` table for auditing and diagnostics.

---

## üõ°Ô∏è Specific Vulnerabilities
- Password recovery flow failures
- Inconsistency in Resend API keys
- Domain verification for email sending
- RLS policies bypass in location tables
- Profile synchronization trigger failures
- Unauthorized access to shared locations
- Rate limiting issues in Edge Functions

---

## üß™ Tests and Validation
- **Auth:** Complete PKCE flow testing for both profiles.
- **Emails:** Validate sending with `test-resend.mjs` and `test-email.mjs`.
- **Database:** Check integrity with diagnostic scripts.
- **Edge Functions:** Test `share-location` with Supabase CLI.
- **RLS:** Validate policies for different user profiles.
- **Critical flows:** Password recovery, location sharing.
- **Integrations:** Supabase Auth, MapBox, Resend.

---

## ‚úÖ Locate-Family-Connect Checklist
- [ ] PKCE Authentication flow tested (login, registration, password recovery)
- [ ] Edge Function `share-location` working correctly
- [ ] Resend API key configured (`re_GaNw4cs9_KFzUiLKkiA6enex1APBhbRHu` or the most recent)
- [ ] Domain `sistema-monitore.com.br` verified in Resend
- [ ] SQL triggers working (especially `handle_new_user()`)
- [ ] RLS policies correctly applied to critical tables
- [ ] Indexes applied for frequent queries
- [ ] Diagnostic scripts successfully executed

---

> **IMPORTANT:** Review this document and the documentation in `/docs/` before modifying critical components. Prioritize authentication flow and location sharing stability. Consult `docs/configuracao-resend.md` and `docs/edge-functions.md` for specific integration details.



**1. Emphasize a Clear Understanding of Existing Code**

* **Modular Architecture:**
    * Stress the importance of understanding Lovable's modular architecture (if applicable). Point out how components, services, and data layers are organized.
    * Encourage developers to identify the specific modules or components they'll be interacting with.
* **Code Documentation and Comments:**
    * Promote the habit of reading existing code comments and documentation (if any).
    * If Lovable has AI-generated code, suggest adding more human-readable comments to clarify logic.
* **Workflow Diagrams:**
    * For complex features, recommend creating or referring to workflow diagrams to visualize data flow and dependencies.
    * This helps developers see the bigger picture and potential ripple effects.

**2. Promote Safe Development Practices**

* **Version Control (Git):**
    * **Branches:** Enforce the use of Git branches for new feature development. This isolates changes and prevents direct modifications to the main codebase.
    * **Small, Incremental Commits:** Advocate for small, focused commits with clear commit messages. This makes it easier to track changes and revert if necessary.
    * **Pull Requests (PRs) and Code Reviews:** Make code reviews mandatory for all new features. This ensures that multiple developers examine the code for potential issues.
* **Testing:**
    * **Unit Tests:** Emphasize the importance of writing unit tests to verify the behavior of individual components or functions.
    * **Integration Tests:** Encourage the creation of integration tests to ensure that different parts of the system work together correctly.
    * **Regression Testing:** Before merging a new feature, perform regression testing to check if existing functionality is broken.
    * **Lovable's Testing Tools:** If Lovable provides any built-in testing tools or frameworks, highlight their usage.
* **Feature Flags:**
    * Introduce the concept of feature flags. This allows developers to deploy new features without immediately enabling them for all users.
    * Feature flags provide a "kill switch" in case something goes wrong in production.

**3. Provide Specific Guidance for Lovable**

* **AI Code Awareness:**
    * Acknowledge that Lovable generates code, which might have subtle dependencies or optimizations.
    * Advise developers to be cautious when modifying AI-generated code and to thoroughly test their changes.
* **Lovable's Abstractions:**
    * If Lovable uses specific abstractions or frameworks, provide guidelines on how to extend them safely.
    * For example, if Lovable has a data access layer, explain how to add new data models or queries without disrupting existing ones.
* **Integration Points:**
    * Clearly document all integration points with external services (APIs, databases, etc.).
    * Warn developers about the potential impact of changes on these integrations.

**4. Documentation and Communication**

* **Detailed Documentation:**
    * Require developers to document their new features thoroughly. This includes:
        * Purpose and functionality
        * Input and output parameters
        * Dependencies on other components
        * Potential side effects
    * Ensure that documentation is updated whenever a feature is modified.
* **Communication:**
    * Foster open communication among developers. Encourage them to ask questions and discuss potential risks.
    * Establish a clear process for reporting and addressing issues.

**Example Documentation Snippet**

Here's an example of how you might incorporate these guidelines into your Lovable documentation:

```
##   Developing New Features Safely

   When implementing new features in Lovable, it's crucial to follow these guidelines to minimize the risk of disrupting existing functionality:

   1.  **Understand the Existing Code:**

       * Familiarize yourself with the relevant modules and components. Refer to architecture diagrams and code comments.
       * Pay close attention to data flow and dependencies.

   2.  **Use Version Control (Git):**

       * Create a new branch for your feature.
       * Make small, incremental commits with clear messages.
       * Submit a Pull Request for code review before merging.

   3.  **Write Thorough Tests:**

       * Write unit tests to verify individual components.
       * Create integration tests to ensure that your feature works correctly with other parts of the system.
       * Perform regression tests to check for unintended side effects.

   4.  **Be Mindful of AI-Generated Code:**

       * Lovable's AI might have introduced subtle dependencies or optimizations. Exercise caution when modifying AI-generated code.
       * Test your changes thoroughly.

   5.  **Document Your Work:**

       * Document the purpose, functionality, and dependencies of your new feature.
       * Update documentation if you modify existing components.

   6.  **Communicate Effectively:**

       * Ask questions and discuss potential risks with other developers.
       * Report any issues promptly.

   By adhering to these guidelines, you can contribute to Lovable's development in a safe and sustainable manner.
```

By consistently emphasizing these practices, you can create a development culture that prioritizes stability and minimizes the risk of introducing regressions.